# static

1.概念：static 是c++关键字，用于控制变量或函数的生命周期、作用域和存储方式

2.特点：

​	a. 变量： 延长生命周期，在程序运行期间一直存在

​	b. 函数： 限制函数作用域在它的文件内部

​	c. 类成员： 属于类而不是对象，可被所有对象共享；

3.函数中的作用，静态局部变量在调用结束后仍然保留其值，下次调用时继续使用上一次的值。

4.全局静态变量或函数外的静态变量：作用域在文件的内部，防止被其他的文件访问

5.static的典型使用场景:计数器或状态保存；类共享数据；限制变量和函数作用域；缓存和单例模式

6.难点：static和const的结合使用；



# RALL和智能指针

1.RALL的本质：资源的生命周期交给对象管理，而不是程序员手动释放；解决方法：把对象封装成对象，在构造函数中获取资源，在析构函数中释放资源；

2.资源可以时堆内存、文件句柄、互斥锁、网络连接等；

3.std::unique_ptr:独占所有权的指针；不能被复制，只能转移；

4.std::shared_ptr:共享式指针；当多个资源需要共享同一个资源时，通过引用计数的方式来追踪资源的使用数量；当技术为0时，自动释放资源；

5.weak_ptr：打破循环引用的解法

RALL思想的运用：std::lock_ground<<std::mutx>> std::thread 



# Lambda:

1.只想在某个范围内使用lambda, 直接使用，减少代码冗余；

2.支持内联优化



# C++ 中数组和指针的区别？

1.数组：表示一段连续的内存区域，大小在编译时固定，名词即代表首元素地址并且不可修改。

2.指针：是一个变量，用于存储某个地址，可以动态指向不同位置。

3.在定义上：数组会为所有元素分配连续的内存空间，指针是一个变量，定义时只分配存储地址的空间；

2.内存布局和存储：数组 为其分配sizeof(类型)*个数字节的连续空间，数组名在大多数表达式中会退化为指向首元素的指针，但它并不是一个可修改的变量； 指针是固定字节（4/8，视平台而定），存储某个地址，指针可以在任意时间通过赋值改变指向，不会自动分配或释放所指内存；

3.取地址与赋值：数组名在表达式中会退化为常量指针，指向首元素地址，但不能对数组名赋新值；指针可以自由赋值，将其指向任意符合类型的地址

4.传递给函数时的区别：当将数组传递给函数时，实际上传递的是指向首元素的指针，函数接收到的参数类型若声明为T arr[]或T* arr，行为相同；

5.指针运算与下标访问：

数组名arr在大多数上下文中退化为&arr[0]，可以使用arr[i]访问第 i 个元素。由于连续内存，可以计算arr + i的地址。
指针 p可以被赋值为指向任何合法元素，通过*(p + i)或p[i]访问下标，但必须确保p指向的区域有足够可访问空间，否则会出现未定义行为。

# 常量指针和指针常量的区别？



# 函数指针和指针函数的区别？

1.函数指针本质是一个指针变量，存储某个函数的入口地址，具有函数签名（返回类型和参数类型）约束，可以通过该指针在运行时调用对应函数；       定义：返回类型 (*指针名)(参数类型列表);

2.指针函数实际上是一个返回指针的函数，调用时会执行函数体逻辑之后返回一个指针； 定义 返回类型* 函数名(参数类型列表);

3.场景：函数指针：回调场景；函数表/策略模式；    指针函数：动态内存分配；返回静态或全局资源；链式接口（返回指向对象成员或数据的指针，用于连续操作或延迟初始化）

4.混淆：形如int *f()并不是一个函数指针，而是“返回int*的函数”；而形如int (*f)()才是“指向返回int的函数的指针”。



# 什么是 C++ 的左值和右值？有什么区别？

1.左值:具有确定存储地址的表达式，这类表达式可以对其取地址并可以作为赋值语句的左侧 	

2.右值：临时对象、字面常量或将亡值，这类表达式没有持久存储地址，只能作为赋值语句的右侧；

3.纯右值：表示临时值或字面常量，没有持久地址，在表达式结束后立即销毁；将亡值：表示一种可移动的资源状态，如std::move(x)的结果或返回的右值引用，表示对象即将被移走

4.存储和地址：左值具有确定存储地址，可以对其取地址；右值通常没有持久存储的地址，不能取地址；

5.赋值行为：左值可以出现赋值运算符的左侧或右侧；右值只能出现在赋值运算符的右侧；

6.生命周期：左值由绑定的对象或变量决定，一直持续到作用域结束；纯右值在表达式结束的时候结束，将亡值在表达式结束时生命周期也结束，只是具备可移走语义

7.T&只能绑定到左值；const T&可以绑定到左值或纯右值，并延长右值生命周期；T&&只能绑定到纯右值或将亡值，用于移动语义和完美转发。



# C++ 中 `shared_from_this` 的作用是什么？它有什么优点？

1.shared_from_this通过std::enable_shared_from_this让类的成员函数能安全地获取一个指向自身的std::shared_ptr；

2.原理：enable_shared_from_this<T>内部保存了一个std::weak_ptr<T>，当第一个shared_ptr<T>构造对象时，内部机制会将该weak_ptr与shared_ptr的控制块关联。调用shared_from_this()时，weak_ptr升级为shared_ptr，引用计数加一。

3.使用前提对象必须已经被至少一个std::shared_ptr<T>管理，否则调用shared_from_this()会抛出std::bad_weak_ptr。不能在栈上或裸指针上直接使用shared_from_this()，否则未关联控制块。

4.优点：避免手动传递和管理裸指针或弱指针，保证与已有shared_ptr共享同一引用计数，实现对象自我管理生命周期。



# 讲一下C++的内存分区



1.代码段、堆区、战区、全局/静态区、常量区；

2.代码段（Text Segment）存放程序的机器指令（可执行代码），在程序加载时由操作系统映射到内存。
通常是只读或可执行，以防止在运行时被修改。所有函数的实际代码都位于此区域，程序一启动就映射到内存中，直到进程结束才释放。

3.堆区:由程序员通过new/delete（或malloc/free）在运行时动态申请和释放。堆区大小由操作系统管理，可以根据需要动态增长和收缩（受进程地址空间和平台限制）。使用不当会造成内存泄漏（忘记delete）或野指针（重复delete），以及内存碎片化等问题。

4.栈区：由编译器自动管理，用于存放函数调用时的局部变量、函数参数、返回地址以及调用现场保存的寄存器值等。
每次函数调用会在栈上分配一个新的栈帧，函数返回时自动释放对应栈帧。栈空间通常较小（几十 KB 至几 MB，视平台而定），如果递归太深或分配过大局部数组，会导致栈溢出（Stack Overflow）。栈的分配和释放仅仅是指针移动，速度非常快，但生命周期受限于函数调用边界。

![image-20251118123617308](assets/image-20251118123617308.png)

栈区位于高地址向低地址方向增长；堆区位于低地址向高地址方向增长

注意

不要在栈上分配过大数组或深度递归，否则可能导致栈溢出。

在堆区分配后一定要记得释放，避免内存泄漏。

常量区内容不可修改，尝试写入常量区会导致段错误。



# 野指针和悬浮指针的概念和区别

1.**野指针**：野指针指的是未被初始化的指针。它没有明确指向一块合法的内存区域，其值是随机的；**悬浮指针**（原因：指针指向的动态内存被free()（C）或delete（C++）释放后，未及时置空）：悬浮指针指的是曾经指向一块合法内存，但该内存已被释放（或回收）后，指针仍保留原地址的指针；

2.危害： 野指针：访问到无效内存导致程序崩溃；意外修改其他变量的内存，引发数据错乱或逻辑错误；悬浮指针：访问悬浮指针可能读取到 “垃圾数据”；若释放的内存被重新分配给其他变量，修改悬浮指针指向的内容会意外篡改新变量，导致逻辑错误；多次释放同一内存（如重复free悬浮指针）会导致内存 损坏；



# c++11/14/17/20区别

1.c++11:现代c++的基础；auto:自动类型推断；加强for循环；右值引用和移动语义；智能指针；lambda表达式；

2.c++14:

```
泛型lambda
auto func = [](auto a ,auto b){return a+b;}
```

```
变量模板
template<typename T>
constexpr T pi = T(3.1415);
```

```
右值引用的改进和constexpr的增强
更多函数可以标记为constexpr
```

3.c++17：

```
1.结构体绑定
std::tuple<int,std::string> t(1,"hello");
auto [num,str] = t;
```

```
2.if、switch的初始化语句
if(auto it = m.find(key);it!=m.end())
{

}
```

```
3.std::optional/std::variant/std::any
std::optional 表示“可能有值或无值”类型，替代传统指针或特殊值判断
std::variant 类型安全的联合体
std::any 可以容纳任意类型的值

```

```
4.并行算法支持
```

4.c++20

```
1.概念（Concepts）
template<typename T>
concept Addable = requires(T a, T b)
{
	{a + b}->std::convertible_to<T>;
}
2.范围库
std::vector<int> v = {1,2,3,4};
auto even = v | std::views::filter([](int n){return n % 2 ==0 });
3.协程
协程使异步编程和生成器模式写法更优雅高效；
4.模板
模板替代头文件机制
5.constexpr的大幅增强
支持更复杂的constexpr函数和算法
```



# STL的六大组件全解析：

1.容器（Containers）
存储数据的载体。比如 vector、list、map、set 等，负责将数据组织成特定的结构，方便操作与访问。
	
2.算法（Algorithms）
提供一整套常用的操作方法，如排序、查找、拷贝、合并等，配合容器使用，提升开发效率。
	
3.迭代器（Iterators）
连接容器与算法的“桥梁”，让算法可以独立于具体容器进行操作。迭代器像一个“指针”，但更灵活、通用。
	
4.仿函数（Functors）
行为类似函数的对象。可以自定义逻辑（如排序规则、筛选条件），使算法更具有可配置性和复用性。
	
5.适配器（Adapters）
对已有组件进行“包装”，改变其接口或行为。常见如容器适配器（stack、queue）、函数适配器（bind、not1 等）。
	
6.空间配置器（Allocators）
负责内存分配与释放的机制，控制容器内部如何申请和管理内存。大多数情况下使用默认配置器，但也是STL的重要组成部分。



# 指针和引用的区别：

1.是否可变：指针指向的内存空间在程序运行过程中可以改变。而引用所绑定的对象一旦绑定就不能改变。

2.是否占用内存：指针本身在内存中占有空间，引用相当于变量的别名，在内存中不占内存空间；

3.是否可以为空：指针可以为空，但是引用必须绑定对象；

4.指针可以有多级，但引用只能有一级；

# 指针和引用值传递的区别是什么

1.值传递是指将参数的值复制一份，传递给函数或方法进行操作。在值传递中，函数或方法对参数进行修改不会影响到原始的变量值。

2.指针引用是指将参数的内存地址传递给函数或方法，使得函数或方法可以直接访问和修改原始变量的值。在指针引用中，函数或方法对参数的修改会直接反映在原始变量上。

# sizeof(1==1) 在 C 和 C++ 中分别是什么结果？

1.明确 == 运算符的返回值类型：C 语言中的结果：关系运算符（如 ==）的返回值类型是 int，sizeof(int)（通常为 4 字节）；C++ 中的结果：sizeof(bool)：关系运算符（如 ==）的返回值类型是 bool；C++ 标准规定 bool 的大小 至少为 1 字节。

# C 和 C++ struct 的区别？

1.在 C 语言中 struct 是用户自定义数据类型；在 C++ 中 struct 是抽象数据类型，支持成员函数的定义。
2.C 语言中 struct 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 struct 可以和类一样，有访问权限，并可以定义成员函数。
3.C 语言中 struct 定义的自定义数据类型，在定义该类型的变量时，需要加上 struct 关键字，例如：struct A var;，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：A var;
4.c++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public;

# C++ 中 struct和Class区别是什么？

**相同：**

1.两者都拥有成员函数、公有、私有部分

2.任何可以使用class完成的工作，同样可以使用struct完成

**不同点**：

1.两者中如果不对成员指定公私有，struct默认是公有的，class则默认是私有的

2.class默认是private继承，而struct默认是public继承

# define宏定义和const的区别

1.编译阶段：define在编译的预处理阶段起作用，而const 是在编译、运行的时候起作用；

2.安全性：define 只做替换，不做类型检查和计算，也不做解，容易出错（最好加上一个大括号包住全部的内容); const常量有数据类型，编译器可以对其进行类型安全检查；

3.内存占用：define 只是将宏名称进行替换，在内存中会产生多份相同的备份；const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果放入常量表；

4.宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中；

5.宏不检查类型；const会检查数据类型

6.宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间；



# define 和 typedef 的区别是什么

1.原理：define作为预处理命令，在编译处理时进行替换操作，不做正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef是关键字，在编译时处理，有类型检查功能，用来给已经存在的类型一个别名，但不能在一个函数定义里使用typedef.

2.功能：typedef 用来定义类型的别名，方便使用。#define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。

3.作用域：#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 typedef 有自己的作用域。

## 4.处理指针不同（带处理）



# volatile 的作用？是否具有原子性，对编译器有什么影响？什么情况使用

1.作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 violatile，告知编译器不应对这样的对象进行优化。

2.没有原子性

3.volatile 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从**内存**缓存到**寄存器**中，防止多个线程有可能使用**内存中的变量**，有可能使用**寄存器中的变量**，从而导致程序错误。

4.当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 volatile 关键字对该变量进行修饰；**中断服务**程序中**访问的变量**或**并行设备的硬件寄存器的变量**，最好用 volatile 关键字修饰；

5.volatile 关键字和 const 关键字可以同时使用；

# 什么是内联函数 和define的区别

1.在C++中，使用关键字"inline"可以声明一个内联函数。声明为内联函数的函数会在编译时被视为候选项，编译器会尝试将其展开，将函数体直接插入到调用点处。这样可以避免函数调用的开销，减少了函数调用的栈帧等额外开销，从而提高程序的执行效率。

2.内联函数是在**编译时**展开，而宏在编**译预处理**时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
3.内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，**避免了函数的参数压栈操作**，减少了调用的开销。而宏定义编写**较为复杂**，常需要增加一些括号来避免歧义。
4.宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是**真正的函数**，会对参数的类型、函数体内的语句编写是否正确等**进行检查**。

# include “ “ 和 <> 的区别是什么

1.查找文件的位置：include<文件名>在**标准库头文件**所在的目录中查找，如果没有，再到当前**源文件所在目录下**查找；#include”文件名” 在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。





# explicit 的作用是什么？

1.作用：用来声明**类构造函数**是**显示调用**的，而非隐式调用的，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。



# memcpy 函数的底层原理是什么？

1.memcpy 函数的底层原理简单说就是直接操作内存块的二进制数据。它会从源地址开始，逐个字节（或按更高效的块）复制数据到目标地址，直到复制完指定的字节数。

2.底层实现通常会做优化，比如对对齐的内存块用更大的单位（如 4 字节、8 字节）批量复制，比单字节循环更快；对未对齐的部分先用单字节处理到对齐位置，再用块复制。整个过程不关心数据类型，纯粹按字节搬运，所以复制后目标内存和源内存的二进制内容完全一致，但不会处理像字符串结束符这类特殊情况。



# C++的函数对象是什么？跟普通函数的区别？

1.函数对象是指一个重载了 operator() 的类或结构体实例。函数对象可以像普通函数一样被调用，但它们实际上是对象，具有状态和行为。

2.区别：

​	定时方式：普通函数是用 返回类型 函数名(参数) 语法定义的，而函数对象是一个类或结构体，并重载了 operator()。
​	状态：普通函数无状态，而函数对象可以有内置的状态（成员变量）。
​	调用方式：普通函数被直接调用，函数对象需要先创建实例，然后用实例调用。
​	灵活性：函数对象可以重载多个操作符或添加更多功能，普通函数则只能定义一个函数。

# 什么是模板？怎么实现

1.模板：创建类或者函数的蓝图或者公式，分为函数模板和类模板。实现方式：模板定义以关键字template开始，后跟一个模板参数列表。

2.模板参数**列表不能为空**；模板类型参数前**必须使用关键字** class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。

3.-函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。

4.类模板：类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。



# 虚拟内存

1.虚拟内存可以使得进程对运行内存超过物理内存大小因为程序运行符合局部性原理，CPU访问内存会有很明显的重复访问的倾向性,对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域

2.由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题

3.页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性



# 虚拟内存用户态的地址空间怎么分配的

![image-20251205185016484](assets/image-20251205185016484.png)

# C++中的内存分区有哪些？

![image-20251205185118576](assets/image-20251205185118576.png)

​      栈区（Stack）：由编译器自动分配释放，存放函数的参数值，局部变量等。其操作方式类似于数据结构中的栈。
​      堆区（Heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意，与数据结构中的堆是两回事，分配方式倒是类似于链表。
​      全局区（静态区）（Static）：全局变量和静态变量被分配到同一块内存中。在C++中，全局区还包含了常量区，字符串常量和其他常量也是存储在此。
​    常量区：是全局区的一部分，存放常量，不允许修改。
​    代码区（Text）：存放函数体的二进制代码。



# 内存对齐

​	内存对齐就是就是将数据存放在内存的某个位置，使得CPU可以更快地访问到这个数据，以空间换时间的方式来提高 cpu 访问数据的性能。



# C++中堆和栈的区别

**1.申请方式：**

栈：由系统自动分配。例如，声明在函数中一个局部变量 int b，系统自动在栈中为b开辟空间。
堆：需要程序员自己申请，并指明大小，在C语言中通过malloc函数，如 p1 = (char *)malloc(10);，在C++中用new运算符，如p2 = new char[20]

**2.申请后系统的响应：**

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

**3.申请大小的限制：**

栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，操作系统中，栈的大小是几MB，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

**4.生命周期：**

栈：栈的内存管理是自动的，变量的内存会在其作用域结束时自动释放
堆：堆的内存管理需要手动进行，需要使用new关键字分配内存，并使用delete或delete[]关键字释放内存，否则会导致内存泄漏。



# new是在内存上的哪一块去分配内存？

1.new所申请的内存区域在c++称为自由存储区。

2.很多编译器的new/delete都是以malloc/free为基础来实现的，所以通常都是借由堆实现来实现自由存储，这时候就可以说new所申请的内存区域在堆上。



# C++ malloc和new的区别是什么？

1.分配内存的位置：malloc是从堆上动态分配内存，new 是从自由存储区为对象动态分配。自由存储区的位置取决于operator new的实现。自由存储区不仅可以为堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

2.返回类型安全性：malloc内存分配成功后返回void*, 然后再强制类型转换成需要的类型；new 操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合类型安全的操作符。

3.内存分配失败返回值：malloc内存分配失败后返回NULL。new分配内存失败则会抛异常（bac_alloc);

4.分配内存的大小计算：：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

5.是否可以被重载：opeartor new /operator delete可以被重载。而malloc/free则不能重载



# delete和free的区别

1.new/delete是C++的操作符，而malloc/free是C中的函数。

2.new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。

3.new/delete 是保留字，不需要头文件支持；malloc/free需要头文件库函数支持

4.new 建立的是一个对象，而malloc 分配的是一块内存；ew建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc分配的是一块内存区域，用指针访问，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。



# malloc 的原理？malloc 的底层实现？

1.**malloc 的原理:**

当开辟的空间小于 128K 时，调用 brk() 函数，通过移动 _enddata 来实现；
当开辟空间大于 128K 时，调用 mmap() 函数，通过在虚拟地址空间中开辟一块内存空间来实现。
2.**malloc 的底层实现：**

brk() 函数实现原理：向高地址的方向移动指向数据段的高地址的指针 _enddata。

![image-20251207155607866](assets/image-20251207155607866.png)

3.**mmap 内存映射原理：**
进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；
调用内核空间的系统调用函数 mmap()，实现文件物理地址和进程虚拟地址的一一映射关系；
进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。

![image-20251207155421819](assets/image-20251207155421819.png)





# const:

​	const 是一个核心关键字，用于定于“不可修改”的实体

①修饰普通变量：只读变量

```

const修饰时，变量的值不能修改（只读）
const 类型 变量名 = 初始值
	const int a = 10;
    // a = 20; // 编译错误：const变量不能修改
```

②修饰指针：3种场景

```
1.指针指向的内容不可更改（const T* p）
const在*左边：指针可以指向其他对象，但指向的内容不能被修改。
	const int* p = &x;
    // *p = 20; // 编译错误：指向的内容不可修改	
2.指针本身不可修改（T* const p）
const在*右边：指针不能指向其他对象，但指向的内容可以修改。
	int* const p = &x;
    *p = 20; // 可以修改指向的内容
    int y = 30;
    // p = &y; // 编译错误：指针本身不能修改
3.指针本身 + 指向的内容都不可修改（const T* const p）
	const int* const p = &x;
    // *p = 20; // 错误：内容不可改
    // p = &y;  // 错误：指针不可改
```

③修饰函数参数：限制参数不可修改

```
1. 修饰基础类型参数
void print(const int a) {
    // a = 20; // 编译错误：参数不可修改
    cout << a << endl;
}
2.修饰指针 / 引用参数（常用）：对于大对象（如std::string、自定义类），用const 类型&传递，可以避免拷贝，同时保证不修改实参
void showString(const string& s) {
    // s = "hello"; // 错误：不能修改
    cout << s << endl;
}
```

④修饰函数返回值：限制返回值不可修改

```
1.返回 const 引用（保护类内部成员）
// 返回const引用：外部只能读，不能改
class Person {
private:
    string name = "张三";
public:
    // 返回const引用：外部只能读，不能改
    const string& getName() const {
        return name;
    }
};

int main() {
    Person p;
    // p.getName() = "李四"; // 错误：返回值是const，不能修改
    cout << p.getName() << endl; // 输出张三
    return 0;
}


```

⑤修饰类的成员函数：常成员函数
	const写在类成员函数的参数列表后，表示这个函数是常成员函数：
		函数内部不能修改任何非 mutable 的成员变量；
		常成员函数可以被const 对象调用（非 const 成员函数不能被 const 对象调用）。

```
class 类名 {
public:
    返回值 函数名(参数) const {
        // 不能修改成员变量（mutable除外）
    }
};
```

⑥修饰类的成员变量：类的常量
const修饰类的成员变量时，必须在构造函数的初始化列表中初始化（不能在函数体内赋值）。

```
class Circle {
private:
    const double pi; // 类的const成员变量
    double r;
public:
    // 必须在初始化列表中初始化pi
    Circle(double r) : pi(3.14159), r(r) {}

    double area() const {
        return pi * r * r;
    }
};

int main() {
    Circle c(2);
    cout << c.area() << endl; // 输出12.56636
    return 0;
}
```

![image-20251219152520292](assets/image-20251219152520292.png)
